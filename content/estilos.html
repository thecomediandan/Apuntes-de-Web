<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../app.css">
    <link rel="stylesheet" href="estilos-style.css">
    <title>Apuntes de CSS</title>
</head>
<body>
    <header>
        <nav>

        </nav>
    </header>
    <article>
        <section>
            <p>El selector universal es <b>*{}</b> con el cual las modificaciones afectan a toda la página.</p>
            <p>El selector por clase es cuando una etiqueta tiene el atributo <i>class="nombreClase"</i> podemos modificar la etiqueta con el nombre de la clase con un punto por delante <i>.nombreClase{}</i>.</p>
            <p>El selector por identificador es cuando una etiqueta tiene el atributo <i>id="nombreID"</i> podemos modificar la etiqueta con el nombre de la clase con un # por delante <i>#nombreClase{}</i>. El identificador es único y no puede haber dos iguales.</p>
            <p>El selector por atributo de etiqueta se pone entre corchetes el atributo y su valor <i>[atributo="nombreAtributo"]{}</i>.</p>
            <p>El selector por elemento es cuando introducimos el nombre de la etiqueta <i>nombreEtiqueta{}</i>.</p>
            <p>Selector por orden descendiente es cuando anteponemos un atributo o nombre de clase y especificamos otros elementos dentro para ser más específicos <i>elementoPadre elementoHijo ...{}</i>.</p>
            <p>La pseudo-clases se activan poniendo ':' y el nombre de la pseudo-clase <i>nombreElemento:nombrePseudoClase{}</i>.</p>

            <p>La especifidad es la forma que podemos cambiar los elementos sin a afectar a otros, los selectores que pertenecen a un mismo grupo de jerarquía, se establece la dinámica de CSS para realizar los cambios en cascada, pero en caso se difiera por elementos superiores en jerarquía entonces se establecerá los cambios por orden de jerarquía. Los estilos en línea son aquellos atributos <i>style="color=red" que se ponen dentro de los atributos de un elemento. El <i>!important</i> va al lado de un atributo en la hoja de estilos <i>*{color: red; !important}</i></i></p>
            <img class="img-1" src="../img/css1.png" title="Jerarquía en especificidad" alt="No se encontró la imagen">
            <p>La metodología BEM es una convención para poder identificar elementos de la página HTML para tener una manera más ordenada al momento de usar los selectores en CSS. Algo importante es que se identifican los elementos por clases, entonces el nombre de clase del contenedor padre por ejemplo <i>class="contenedor-padre"</i> sería algo asi, en cambio del hijo sería algo asi <i>class="contenedor-padre__contendor-hijo"</i>, si nos basamos en esta lógica los contenedores "nietos" y los que le siguen sería algo asi <i>class="contenedor-padre__contendor-hijo-nieto"</i>, ahora si queremos diferenciar un grupo de elementos que llevan el mismo nombre de clase por ejemplo este <i>class="contenedor-padre__contendor-hijo-nieto"</i>, tenemos cuatro elementos igual y queremos seleccionar solo el primero entonces lo nombraríamos algo así <i>class="contenedor-padre__contendor-hijo-nieto--active"</i>, tambien hay otra manera, pero en la hoja de estilos <i>contenedor-padre__contendor-hijo-nieto:first-child{}</i>.</p>
        </section>
        <section>
            <p>La unidades de medidas que pueden ser en <b>%, cm, mm, rem, em, px, etc.</b> En este caso trataremos algunas, por ejemplo la medida relativa <b>em</b>, por defecto la mayoría de navegadores le da el valor de <b>16px</b> a una unidad <b>em</b>, pero este a su vez puede ser modificado si es parte de un contenedor padre que modifique en pixeles o cualquier unidad estática al atributo deseado, la unidad en <b>em</b> del atributo será igual a la unidad puesta en el contenedor padre del mismo atributo.</p>
        </section>
        <section>
            <p>El atributo <b>font-size</b> tamaño de letra, <b>font-family</b> es el tipo de letra si queremos personalizar otro tipo de fuentes podemos usar Google Fonts, se puede poner fuentes de respaldo usando comas y poniendo todos los tipos de fuentes posibles hasta que uno pueda encontrarse, <b>line-height</b> es la unidad del tamaño de letra, <b>font-weight</b> es el grosor del tipo de letra, algo como un bold.</p>
            <p>Para el Reset de CSS, es decir poner todo completamente por defecto se pueden utilizar algunas hojas de estilo predefinidas como el Normalize, existen otras maneras de poner todo por defecto, como el archivo <a href="https://github.com/eduardofierropro/Reset-CSS">https://github.com/eduardofierropro/Reset-CSS</a>, del video de YouTube <a href="https://www.youtube.com/watch?v=Foieq2jTajE">https://www.youtube.com/watch?v=Foieq2jTajE</a>, del canal de <i>Eduardo Fierro</i>, que es el que utilizaremos, dentro del archivo podemos ver que tipo de modificaciones son las que haremos, hay algunas que no nos convendrían, todo depende de hasta donde queremos llegar y como lo queremos hacer.</p>
            <iframe width="560" height="315" src="https://www.youtube.com/embed/Foieq2jTajE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>           
        </section>
        <section>
            <p>Elementos en <b>línea</b> y en <b>bloque</b>, el elemento en <b>línea</b> es aquel elemento que ocupa el espacio del contenido en cambio el elemento en <b>bloque</b> ocupa todo el ancho con salto de línea, en los elementos en <b>línea</b> pueden ir de manera seguida en una línea hasta que la anchura lo permita.</p>
            <p>Todo esto puede modificarse, por ejemplo podemos modificar un elemento en bloque en <b>línea</b> con CSS con la propiedad <i>h2{display: inline-block;}</i>, pero tambien hay propiedades que no se aplican, como por ejemplo en elementos en <b>bloque</b> propiedades como <i>height</i> o <i>width</i>.</p>
            <p>Las propiedades de caja son importantes para el diseño, algunas de ellas son: <i>background-color</i> cambia el fondo del elemento, <i>display</i> cambia el tipo de elemento a bloque o en línea, <i>padding</i> son cuatro y cambia el margen interno del elemento, <i>height</i> es el alto del elemento, <i>width</i> es el ancho del elemento, <i>box-sizing</i> con sus propiedades <b>border-content</b> que admite los cambios del padding con los de height y width, <b>border-box</b> que ignora el padding y solo toma en cuenta los cambios en el height y width, esto puede dejar el contenido del elemento fuera visualmente, <i>text-align</i> modifica el alineamiento del texto dentro del elemento,  <i>margin</i> es casi igual que el padding, tambien son cuatro, la diferencia es que es el margen externo del elemento, <i>border-radius</i> permite redondear los bordes del elemento, <i>border-style</i> modifica el estilo del borde, <i>border-color</i> modifica el color del borde, el estilo del borde puede ser modificado usando solo <i>border</i> y podemos modificar el tamaño  seguido del estilo y el color.</p>
            <img src="../img/css2.png" alt="" title="Jerarquía Box-Model">
            <p><i>box-shadow</i> modificamos la sombra del elemento.</p>
            <img src="../img/css3.png" alt="" title="box-shadow">
            <p><i>text-shadow</i> modificamos la sombra del elemento de texto.</p>
            <img src="../img/css4.png" alt="" title="text-shadow">
            <p>El <b>outline</b> es una propiedad parecida al border pero no afecta a otros elementos ni al propio elemento como lo hace border reduciendo el tamaño de del elemento, su sintaxis es resumida <i>outline: 5px solid red;</i>, y tiene mucho que ver el <b>z-index</b> por el orden en pila de los elementos.</p>
            <p>La posición  de los elementos puede modificarse con las siguientes propiedades: STATIC, RELATIVE, ABSOLUTE, FIXED y STICKY. Siendo la posición <b>static</b> la por defecto.<br>
            Al introducir el atributo de posición relativa <i>position: relative;</i> por defecto se activa el atributo <i>z-index</i> el cual nos pone un nivel sobre todos los otros elementos en el eje-z, el cual con los atributos <i>top, bottom, right y left</i> podemos mover el elemento sin que afecte a sus espacio asignado, es decir podremos mover todo el elemento por encima de los demás pero su espacio seguirá en su lugar.<br>
            Al introducir el atributo de posición absoluta <i>position: absolute;</i> por defecto se activa el atributo <i>z-index</i> el cual nos pone un nivel sobre todos los otros elementos en el eje-z, el cual con los atributos <i>top, bottom, right y left</i> podemos mover el elemento afectando su espacio asignado, es decir podremos mover todo el elemento por encima de los demás pero su espacio perderá su lugar, en caso de que el elemento no se defina su ancho y altura, este se ajustara al contenido sin importar que sea un elemento en bloque. Si no se define <i>top, bottom, left o right</i> o el contenedor del elemento no esta posicionado entonces se tomará como punto de referencia el <b>viewport</b> para poder desplazar el elemento. <span>NOTA: para centrar horizontalmente podemos utilizar el atributo <i>margin: 50px auto;</i> por ejemplo, la transparencia podemos modificarla con el atributo <i>opacity</i> el cual se puede modificar a partir de 0 a 1.</span><br>
            El atributo de posicion <i>fixed</i> sirve para fijar el contenedor y su sintaxis es <i>position: fixed;</i> y es parecido al posicionamiento <i>absolute</i> que pierde su espacio pero a su vez este que fijado en la pantalla.<br>
            El atributo de posición <i>sticky</i> es como una mezcla del <b>relative</b> y <b>fixed</b>, porque puede conservar su espacio como el <b>relative</b> pero cuando pasa por el scroll este queda fijado como el <b>fixed</b>.</p>
            <p>El atributo <i>display</i> es muy importante tambien para darle forma a los elementos de los cuales vimos <i>display: block;</i> que hace que el elemento se comporte como bloque, <i>display: inline;</i> que hace que los elementos se comporten como elementos en línea y solo se muestra el contenido y no el espacio del contenedor, <i>display: inline-block</i> que hace que un elemento sea como un bloque pero pueda estar en línea. Tambien tenemos los más importantes como el <b>flex</b> y <b>grid</b> que los veremos más adelante.</p>
            <p>El atributo <i>overflow</i> nos ayuda a controlar el desbordamiento de texto de los contenedores o elementos con una barra de scroll, los valores son: <i>inherit</i> que es el valor por defecto que nos muestra el texto desbordado, <i>hidden</i> que nos oculta el valor desbordado, <i>auto</i> que nos oculta el texto desbordado pero además nos pone barras de scroll por si es necesario, <i>scroll</i> que nos pone la barra de scroll aunque no sea necesario.</p>
            <p>El atributo <i>float</i> sirve para poder poner un elemento flotante y poder ajustarlo a uno de los lados, generalmente se utiliza para poder poner imágenes al lado de textos para que el texto se auto-ajuste a la imágen.</p>
        </section>
        <section>
            <p>Los <b>Pseudo-elementos</b> son como funciones que podemos aplicar a lso elementos. Por ejemplo tenemos a <i>::first-line</i> que selecciona la primera linea de un elemento en bloque, <i>first-letter</i> que selecciona a la primera letra de un texto de un elemento, <i>::placeholder</i> que es un atributo generalmente en elementos del tipo <i>input</i> que nos permite personalizar el <i>placeholder</i> tomando en cuenta que son elementos en línea, <i>::selection</i> que personaliza la seleccion de los textos con el mouse, es decir el fondo o color del texto seleccionado, <i>elemento::before{}</i> es un pseudo-elemento en línea que modifica al elemento seleccionado y con el atributo <b>content</b> escribimos el texto que queramos que este antes del elemento seleccionado y <i>elemento::after{}</i> es lo mismo que <i>elemento::before{}</i> solo que funciona para modificar al final del elemento seleccionado.</p>
        </section>
        <section>
            <p>Las <b>Pseudo-clases</b> son como funciones que escuchan ciertos eventos, algunos de ellos son: <i>::hover</i> que funciona cuando posicionamos el cursor del mouse encima del elemento seleccionado, <i>::visited</i> funciona cuando se visite links, <i>::active</i> funciona cuando mantenemos presionado o activo el elemento seleccionado</p>
        </section>
        <section>
            <p>La propiedad <i>Object-Fit</i> sirve mas que todo para imágenes, el atributo <i>width</i> en las imágenes redimensiona toda la imagen a través de ese parámetro.</p>
            
            <div class="ejemplo-numero-1">
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css12.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>               
                    <div class="ejemplo-object-fit img1">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>Sin el atributo</i>
                        <img src="../img/css6.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css13.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>
                    <div class="ejemplo-object-fit img2">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>object-fit: contain;</i>
                        <img src="../img/css7.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css14.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>
                    <div class="ejemplo-object-fit img3">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>object-fit: cover;</i>
                        <img src="../img/css8.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css15.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>
                    <div class="ejemplo-object-fit img4">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>object-fit: fill;</i>
                        <img src="../img/css9.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css16.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>
                    <div class="ejemplo-object-fit img5">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>object-fit: none;</i>
                        <img src="../img/css10.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
                <div class="ejemplo-aplicado-1">
                    <div class="ejemplo-object-fit__img-1">
                        <img src="../img/css17.png" alt="Imágen no encontrada" title="Código HTML">
                    </div>
                    <div class="ejemplo-object-fit img6">
                        <img src="../img/no-image.png" alt="Imágen no encontrada" title="Ejemplo">
                    </div>
                    <div class="ejemplo-object-fit__img-2">
                        <i>object-fit: scale-down;</i>
                        <img src="../img/css11.png" alt="Imágen no encontrada" title="Código CSS">
                    </div>
                </div>
            </div>
            
            <img src="../img/css5.png" alt="Imágen no encontrada" title="Código CSS">
            <p>Como podemos ver en los ejemplos las imágenes tienen efectos diferentes con cada valor del atributo <b>object-fit</b>.<br>
            El atributo <b>Object-Position</b> es para mostrar la imágen en los cuatro lados con <i>top, bottom, left, right</i> o cualquier valor numérico válido.<br>
            El atributo <b>cursor</b> nos cambia el tipo de cursor.</p>
        </section>
        <section>
            <p>Para la <b>colorización</b> podemos apoyarnos de páginas para elegir paletas de colores o para selección de colores como <a href="https://webaim.org/resources/contrastchecker/">https://webaim.org/resources/contrastchecker/</a>. Se recomienda utilizar colores en hexadecimal:</p>
            <img src="../img/css18.png" alt="Imágen no encontrada" title="Colores en hexadecimal">
        </section>
        <section>
            <p>Los conceptos de <b>Responsive Design</b> a la práctica que toma en cuenta varias resoluciones para el diseño de páginas web, para que puedan ajustarse por ejemplo a resoluciones más pequeñas como las de un celular o tablet en cambio <b>Mobile First</b> que es inverso que la de <b>Responsive Design</b> que empieza en resoluciones pequeñas para poder adaptarse a resoluciones más grandes como las de navegadores de escritorio.</p>
            <p>Para aplicar <b>Responsive Design</b> tenemos algo que se llama <i>Media Query</i>, que es un complemento que lleva CSS para detectar resoluciones con <i>@media</i>. Para que sea posible detectar la resolucion de un celular necesitaremos del <i>Meta ViewPort</i>, esto lo podemos conseguir de cualquier página web y es una etiqueta <b>&lt;meta&gt;</b> que viene configurada para poder reconocer móviles, hasta la fecha de este documento viene por defecto en HTML5. Una manera básica de utilizar <b>Responsive Design</b> es con el siguiente código <i>@media only screen and (max-width: 800px){}</i> o <i>@media screen and (max-width: 800px){}</i> lo que significa que cuando la resolución sea menor a 800px podemos cambiar los elementos que quisieramos.</p>
            <img src="../img/css19.png" alt="No se encontró la imagen">          
        </section>
        <section>
            <p><b>FLEX</b> es una funcionalidad de CSS para el manejo de los elementos dentro de un contenedor. El contenedor internamente tiene ejes llamados <b>main axis</b> que haría referencia al eje <i>x</i> y <b>cross axis</b> al eje <i>y</i>, <b>main axis</b> a su vez esta dividido en <i>main-start</i> y <i>main-end</i>, <b>cross axis</b> en <i>cross-start</i> y <i>cross-end</i>. <b>main axis</b> tiene la dirección por defecto de izquierda-derecha, <b>cross axis</b> de arriba-abajo. Cuando configuramos un elemento como <i>display: flex;</i> solamanete afecta como items de flex a los hijos directos.</p>
            <p>Después de de implementar la propiedad <b>display: flex;</b>, podemos implementar los siguientes atributos como <b>flex-direction</b> que cambia la alineación de los items flex, es decir los elementos dentro del contenedor que convertimos en <b>flex</b>, estos valores pueden ser <i>row, row-reverse, column, column-reverse</i>, <i>row</i> hace que los items se comporten como fila y <i>row-reverse</i> invierte el orden en fila, <i>column</i> y <i>column-reverse</i> son igual que los anteriores solo que el orden de los items es en columna.<br>
            El atributo <b>flex-wrap</b> con el valor <i>flex-wrap: wrap;</i> o <i>flex-wrap: wrap-reverse;</i> hace que el ancho de los items se respete y que si afecta posiciona los elementos sobrantes debajo o arriba dependiendo del valor asignado, todo esto en manera de filas.<br>
            El atributo <b>justify-content</b> posiciona los items flex dependiendo de sus valores, <i>justify-content: center;</i> centra los items tal cual como si pusieramos <i>margin: auto;</i>, <i>justify-content: space-between;</i> hace que el espacio se reparta entre los items excepto de los lados, <i>justify-content: space-around;</i> es como <i>margin: auto;</i>, <i>justify-content: space-evenly;</i> el espacio entre los items se reparte equitativamente aún en los extremos.<br>
            Para alinear en el <b>cross axis</b> osea en el eje <i>y</i>, se utilizan las siguientes propiedades, <b>align-items</b> que solo se aplica a la primera línea, pero este problema puede solucionarse si se combina con los valores de la propiedad <b>align-content</b>. <b>align-items</b> con sus valores <i>align-items: stretch;</i> que es valor por defecto, <i>align-items: center;</i> lo que hace es centrar los items tanto vertical y horizontalmente, <i>align-items: flex-end;</i> posiciona los items al final del contenedor, es decir abajo, <i>align-items: flex-start;</i> nos posiciona los elementos arriba, pero con la diferencia de que si no definimos la altura en los items este se ajustará al contenido, algo que no sucede con <i>align-items: stretch;</i> que hace que la altura se nos vaya hasta abajo donde nos permita el <b>cross axis</b>.<br>
            <b>align-content</b> es el atributo que nos permitirá alinear los items de un contenedor flex, digamos que sirve generalmente para que se apliquen los cambios a todas las líneas de los cambios realizados con el atributo <b>align-items</b>, el valor <i>align-content: baseline;</i> sirve más que todo para solucionar problemas con el <i>flex-wrap: wrap-reverse;</i>.<br>
            <i>Las propiedades de los items</i> bueno por ahora hemos estado dando propiedades a los contenedores flex, pero existen propiedades para los items en flex, (los <i>margins</i> en los items actuan diferente cuando introducimos valores <i>auto</i> porque consume todo el espacio) <i>align-self</i> que nos posiciona el item en dostintos lugares pero verticalmente (cross axis), <i>flex-grow</i> toma valores con números enteros lo que hace es repartir el espacio disponible dependendiendo del valor de <i>flex-grow</i> y en donde se lo esta dando, si el valor esta en el contenedor flex, el espacio se repartirá equitativamenteentre todos los items, pero si se le da a los items este se distribuirá debido al valor asignado.<br>
            La propiedad <b>flex-shrink</b> nos permite elegir cuanto más debe ceder uno o varios items cuando el espacio se haya terminado, es como el inverso de <i>flex-grow</i> que nos permitía agregar cuanto espacio disponible debería repartirse en uno o varios items, en este caso es cuanto espacio debería ceder uno o varios items cuando el espacion se haya terminado.<br>
            La propiedad <b>flex-basis</b> es como un width pero este es específico para items flex.<br>
            La propiedad <b>order</b> es como el <i>z-index</i> solo que en el <i>main axis</i> o en el eje <i>x</i>, el valor más grande es el que se superpone a los menores.</p>
        </section>
        <section>
            <p><b>GRID</b> es un estilo de layout al igual que <b>FLEX</b>, un valor de la propiedad <i>display</i>, un layout de estilo grilla. El <i>Grid Container</i> es el contenedor con el valor <i>grid</i>, y podemos definir los elementos dentro como <b>grid items</b> y los <i>grid cell</i>, son los espacios designados, podemos imaginar celdas reservadas para cada item, <i>grid tracks</i> son el numero de filas y columnas, <i>grid area</i> no estan definidas por defecto, se tiene que dar un valor y ocupan más de una celda y son consecutivas, en forma rectangular, <i>grid line</i> son las líneas de las columnas y filas.<br>
            Cuando creamos un <b>grid container</b> por defecto los items se ponen en una columna, esto si no modificamos las demás propiedades. Algunas propiedades importantes son: <b>grid-template-rows: medida-fila-1 medida-fila-2 medida-fila-3...;</b> y <b>grid-template-columns: medida-columna-1 medida-columna-2 medida-columna-3...;</b> que creamos la plantilla de la grilla, como dato adicional con la unidad de medida <b>fr</b> podemos desiganar cuantas partes del espacio disponible queremos asignar a una fila o columna.<br>
            Para manejar los espacios entre los items, tenemos a <b>row-gap</b> y <b>column-gap</b> que pone un espaciado con el valor que se le de solo entre los elementos de la grilla sin contar espaciado al borde del contenedor.<br>
            Si queremos manejar los espacios de la grilla (cell), podemos utilizar las propiedades de <b>grid-row</b> y <b>grid-column</b>, esto funciona si queremos personalizar la distribución de los espacios de la grilla, el formato de los valores es <i>linea-inicio / linea-final</i>, un ejemplo sería: <i>grid-column: 1 / 3;</i>, con esto decimos que queremos que la columna del item numero uno se desplace hasta final de la columna dos, si mezclamos esto con <i>grid-row: 1 / 3;</i> habremos desplazado el item número uno en las primeras dos primeras columnas y filas, haciendo recorrer los demás elementos fuera de la grilla.</p>

            <div class="ejemplo-dos">
                <div class="ejemplo-grilla">
                    <div class="ejemplo-grilla_item">
                        <b>1</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>2</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>3</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>4</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>5</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>6</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>7</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>8</b>
                    </div>
                    <div class="ejemplo-grilla_item">
                        <b>9</b>
                    </div>
                </div>
            </div>

            <div class="imagenes-ejemplo-dos">
                <img src="../img/css20.png" alt="Imagen no encontrada">
                <img src="../img/css21.png" alt="Imagen no encontrada">
            </div>

            <p>Tambien podemos poner como valores por ejemplo <i>grid-row: 1 / span 3;</i>, lo que hace <i>span</i> es decir que llegará a ocupar desde la línea 1 de la fila, hasta ocupar 3 filas.<br>
            Algunas funciones que pueden facilitarnos la creación de celdas (cells), en los atributos <b>grid-template-rows: medida-fila-1 medida-fila-2 medida-fila-3...;</b> y <b>grid-template-columns: medida-columna-1 medida-columna-2 medida-columna-3...;</b>, es la función <i>repeat(x, y)</i>, que suele utilizarse para la creación celdas en columnas y filas, de manera que pueda acortarnos el trabajo, siendo <b>x</b> el número de celdas que queremos y <b>y</b> el tamaño que queremos que ocupen cada una de las celdas, dependiendo de la orientación (columna o fila), pero se puede poner muchas medidas y todas ellas serán replicadas <b>x-veces.</b>.</p>
            <p><b>Grid Explícito</b> y <b>Grid Implícito</b> son las maneras en que pueden presentarse, el Grid Explícito es la grilla definida en el contenedor grilla, y el Grid Implícito es aquel que sale fuera de la grilla, como vimos en el ejemplo de las propiedades <b>grid-row y grid-column</b>.<br>
            Podemos la parte del <b>Grid Implícito</b> con algunas propiedades, <b>grid-auto-columna</b> y <b>grid-auto-columna</b> son para controlar el <b>Grid Implícito</b> los valores puestos son para darle el tamaño a todas las celdas sea columna o fila, <b>grid-auto-flow</b> es un atributo que puede hacer que el <b>Grid Implícito</b> se comporte como columnas, porque este por defecto nos lo ponen como filas, esto con el valor <i>grid-auto-flow: column;</i>, con el valor <i>grid-auto-flow: dense;</i> nos rellena las celdas en blanco con elementos dentro de la grilla si es que el caso pueda darse</p>
            <p><b>EL GRID DINÁMICO</b>sirve para construir una grilla dinámica con funciones como <b>minmax</b> que sirve para introducir un intervalo de valores, generalmente medidas, un ejemplo sería <i>grid-template-columns: repeat(3, minmax(100px, 300px));</i> el cual nos diría que queremos crear 3 columnas y que sus medidas sean como mínimo 100px y como máximo 300px, los items se estirarán hasta cumplir esos valores, tambien contamos con funciones como <i>min-content y max-content</i> que son las medidas mínimas y máximas de los elementos dentro de los items. La funcion <b>auto-fill</b> es un valor que hace referencia a las cantidades de celdas que por ejemplo podemos a plicarlas a generacion de columnas como <i>grid-template-columns: repeat(auto-fill, minmax(100px, 200px))</i>, en este ejemplo se crearan columnas dinamicamente cuando el espacio disponible cumpla las condiciones del <i>minmax</i>, recorriendo los items de las celdas siguientes al espacio de la celda generado automaticamente, la funcion <b>auto-fit</b> escala los items de modo que ocupe todo el ancho o alto disponible.<br>
            Para el alineamiento utilizaremos las propiedades como <b>justify-item</b> que con sus valores <i>start, center, end</i> o <i>flex-start, flex-center, flex-end</i> que nos ayudara a mover los items en esas posiciones de manera horizontal, para posicionar los elementos de manera vertical usamos la propiedad <b>align-items</b> con sus valores <i>start, center, end</i>, para alinear las columnas y filas utilizamos las siguientes propiedades: <b>justify-content</b> con sus valores <i>start, center, end</i> posiciona las columnas en esas posiciones, otra manera de verlo es que posiciona toda la grilla horizontalmente, <b>align-content</b> con sus valores <i>start, center, end</i> posiciona las filas en esas posiciones, otra manera de verlo es que posiciona toda la grilla verticalmente, hay algunas valores de <b>flex</b> que se mantienen como <i>space-around, space-between, space-evenly</i> que tienen los mismos efectos esto solo en las propiedades <b>justify-content y align-content</b>.<br>
            Todo lo visto con respecto a la alineacion funciona muy bien en el contenedor grilla, pero tambien podemos alinear por celda con las siguientes propiedades <b>justify-self</b> para posicionar de manera horizontal y <b>align-self</b> de manera vertical con los valores <i>start, center, end</i>.<br>
            La propiedad <b>order</b> funciona igual que el <i>z-index</i> que con un numero ubicamos las prioridades de los items toman en cuenta que el numero alto va primero.</p>
        </section>
        <section>
            <p>
                El <b>Grid Area</b> son grupos de celdas consecutivas a partir de dos celdas que pueden estar en cualquier parte de la grilla.
            </p>
        </section>
    </article>
    <aside>

    </aside>
    <footer>

    </footer>
</body>
</html>